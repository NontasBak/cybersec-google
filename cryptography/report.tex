\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{pgfplots}
\pgfplotsset{compat=1.17}
\usepackage{afterpage}
\usepackage{float}
\usepackage{hyperref}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{xcolor}
\graphicspath{{assets/}}

% Configure listings for Python code
\lstset{
    language=Python,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=8pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    rulecolor=\color{black},
    tabsize=4,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={(*@}{@*)},
    xleftmargin=2em,
    framexleftmargin=1.5em
}

\title{Cryptography Exercises Report}
\author{Epameinondas Bakoulas}
\date{November 2025}

\begin{document}

\maketitle

\section{Exercise 1: Vigen√®re Cipher}

\subsection{Finding the Key}

We organize the ciphertext \texttt{LXFOPVEFRNHR} into 5 batches based on the key length of 5.

\begin{itemize}
    \item \textbf{Batch 1:} Letters at indices 0, 5, 10 (\texttt{L}, \texttt{V}, \texttt{H})
    \item \textbf{Batch 2:} Letters at indices 1, 6, 11 (\texttt{X}, \texttt{E}, \texttt{R})
    \item \textbf{Batch 3:} Letters at indices 2, 7 (\texttt{F}, \texttt{F})
    \item \textbf{Batch 4:} Letters at indices 3, 8 (\texttt{O}, \texttt{R})
    \item \textbf{Batch 5:} Letters at indices 4, 9 (\texttt{P}, \texttt{N})
\end{itemize}

Frequency table for each batch:

\begin{table}[H]
\centering
\footnotesize
\renewcommand{\arraystretch}{1.3}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\textbf{\#} & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{I} & \textbf{J} & \textbf{K} & \textbf{L} & \textbf{M} & \textbf{N} & \textbf{O} & \textbf{P} & \textbf{Q} & \textbf{R} & \textbf{S} & \textbf{T} & \textbf{U} & \textbf{V} & \textbf{W} & \textbf{X} & \textbf{Y} & \textbf{Z} \\
\hline
\textbf{\#1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \textbf{1} & 0 & 0 & 0 & \textbf{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \textbf{1} & 0 & 0 & 0 & 0 \\
\hline
\textbf{\#2} & 0 & 0 & 0 & 0 & \textbf{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \textbf{1} & 0 & 0 & 0 & 0 & 0 & \textbf{1} & 0 & 0 \\
\hline
\textbf{\#3} & 0 & 0 & 0 & 0 & 0 & \textbf{2} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
\textbf{\#4} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \textbf{1} & 0 & 0 & \textbf{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
\textbf{\#5} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \textbf{1} & 0 & \textbf{1} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
\hline
\end{tabular}%
}
\caption{Frequency distribution of letters in each batch}
\end{table}

We analyze each batch to find the shift that maps the letters to high-frequency English letters (such as \texttt{e}, \texttt{t}, \texttt{a}, \texttt{o}, \texttt{i}, \texttt{n}).

\subsubsection{Batch 3 Analysis}

\textbf{Letters:} \texttt{F}, \texttt{F}

The letter \texttt{F} appears 100\% of the time. If \texttt{F} (5) corresponds to the common letter \texttt{t} (19):
\begin{align*}
    \text{Shift} &= 5 - 19 = -14 = 12 \pmod{26}
\end{align*}

The 12th letter is \textbf{M}.

\subsubsection{Batch 4 Analysis}

\textbf{Letters:} \texttt{O}, \texttt{R}

We have \texttt{O} (14) and \texttt{R} (17), which are 3 spots apart. Common letters separated by 3 spots are \texttt{a} (0) and \texttt{d} (3).
\begin{align*}
    \text{Shift} &= 14 - 0 = 14
\end{align*}

The 14th letter is \textbf{O}.

\subsubsection{Batch 5 Analysis}

\textbf{Letters:} \texttt{P}, \texttt{N}

If \texttt{N} maps to \texttt{a} (0), the shift is 13:
\begin{align*}
    \text{P: } 15 - 13 &= 2 \text{ (\texttt{c})} \\
    \text{N: } 13 - 13 &= 0 \text{ (\texttt{a})}
\end{align*}

``ca'' seems valid. The 13th letter is \textbf{N}.

\subsubsection{Batch 1 Analysis}

\textbf{Letters:} \texttt{L}, \texttt{V}, \texttt{H}

If we try Key \textbf{L} (11):
\begin{align*}
    \text{L: } 11 - 11 &= 0 \text{ (\texttt{a})} \\
    \text{V: } 21 - 11 &= 10 \text{ (\texttt{k})} \\
    \text{H: } 7 - 11 &= -4 \equiv 22 \text{ (\texttt{w})}
\end{align*}

``akw'' seems valid.

\subsubsection{Batch 2 Analysis}

\textbf{Letters:} \texttt{X}, \texttt{E}, \texttt{R}

If we try Key \textbf{E} (4):
\begin{align*}
    \text{X: } 23 - 4 &= 19 \text{ (\texttt{t})} \\
    \text{E: } 4 - 4 &= 0 \text{ (\texttt{a})} \\
    \text{R: } 17 - 4 &= 13 \text{ (\texttt{n})}
\end{align*}

``tan'' seems valid.

\subsection{Recovered Key and Decryption}

\textbf{Recovered Key:} \texttt{LEMON}

We decrypt using the formula $P = (C - K) \bmod 26$:

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Cipher} & \textbf{Key} & \textbf{Calculation} & \textbf{Plaintext} \\
\hline
L (11) & L (11) & $11 - 11 = 0$ & a \\
X (23) & E (4) & $23 - 4 = 19$ & t \\
F (5) & M (12) & $5 - 12 = -7 \equiv 19$ & t \\
O (14) & O (14) & $14 - 14 = 0$ & a \\
P (15) & N (13) & $15 - 13 = 2$ & c \\
V (21) & L (11) & $21 - 11 = 10$ & k \\
E (4) & E (4) & $4 - 4 = 0$ & a \\
F (5) & M (12) & $5 - 12 = -7 \equiv 19$ & t \\
R (17) & O (14) & $17 - 14 = 3$ & d \\
N (13) & N (13) & $13 - 13 = 0$ & a \\
H (7) & L (11) & $7 - 11 = -4 \equiv 22$ & w \\
R (17) & E (4) & $17 - 4 = 13$ & n \\
\hline
\end{tabular}
\caption{Decryption process for each character}
\end{table}

\textbf{Decrypted Message:} \texttt{attackatdawn}

\section{Exercise 2: RSA Encryption and Decryption}

\subsection{Calculate $n$, $\varphi(n)$, and the Private Exponent $d$}

Given: $p = 197$, $q = 211$, $e = 24377$

\subsubsection{Calculate $n$}
\begin{align*}
    n &= p \times q \\
    n &= 197 \times 211 = 41567
\end{align*}

\subsubsection{Calculate $\varphi(n)$}
\begin{align*}
    \varphi(n) &= (p - 1) \times (q - 1) \\
    \varphi(n) &= (197 - 1) \times (211 - 1) \\
    \varphi(n) &= 196 \times 210 = 41160
\end{align*}

\subsubsection{Find $d$}

We need to find $d$ such that $e \cdot d \equiv 1 \pmod{\varphi(n)}$, or equivalently:
\begin{equation*}
    24377 \cdot d \equiv 1 \pmod{41160}
\end{equation*}

Using the Extended Euclidean Algorithm:

\begin{lstlisting}[caption=Computing the private exponent]
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

p, q, e = 197, 211, 24377

n = p * q
phi = (p - 1) * (q - 1)

g, d, _ = egcd(e, phi)
d = d % phi  # Ensure d is positive

print(f"n: {n}")
print(f"phi: {phi}")
print(f"d: {d}")
\end{lstlisting}

\textbf{Results:}
\begin{itemize}
    \item $n = 41567$
    \item $\varphi(n) = 41160$
    \item $d = 17393$
\end{itemize}

Verification: $e \times d = 24377 \times 17393 = 423989161 \equiv 1 \pmod{41160}$

\subsection{Encrypt and Decrypt}

\subsubsection{Encryption}

Using the formula $C = m^e \bmod n$:
\begin{align*}
    C &= 1234^{24377} \bmod 41567
\end{align*}

\begin{lstlisting}[caption=RSA encryption]
M = 1234
e = 24377
n = 41567

C = pow(M, e, n)
print(f"Cipher text: {C}")
\end{lstlisting}

\textbf{Result:} $C = 26476$

\subsubsection{Decryption}

Using the formula $M = C^d \bmod n$:
\begin{align*}
    M &= 26476^{17393} \bmod 41567
\end{align*}

\begin{lstlisting}[caption=RSA decryption]
d = 17393
M_decrypted = pow(C, d, n)
print(f"Plain text: {M_decrypted}")
\end{lstlisting}

\textbf{Result:} $M = 1234$ (original plaintext successfully recovered)

\subsection{Square-and-Multiply Algorithm}

To calculate $1234^{24377} \bmod 41567$, we use the square-and-multiply algorithm.

\subsubsection{Binary Representation}
\begin{equation*}
    24377_{10} = 101111100111001_2
\end{equation*}

\subsubsection{Algorithm Steps}

The algorithm processes each bit from left to right. For each '0' bit, we \textbf{square}. For each '1' bit, we \textbf{square and multiply} by the base. Each step is performed modulo $n$.

\begin{lstlisting}[caption=Square-and-multiply implementation]
def square_and_multiply(base, exponent, modulus):
    binary_exp = bin(exponent)[2:]
    
    print(f"Exponent: {exponent}")
    print(f"Binary:   {binary_exp}\n")
    
    print(f"{'Step':<5} | {'Bit':<3} | {'Operation':<17} | "
          f"{'Calculation':<25} | {'Result':<5}")
    print("-" * 70)
    
    # First step: Initialization (MSB is always 1)
    result = base
    print(f"{'1':<5} | {'1':<3} | {'Initial':<17} | "
          f"{'-':<25} | {result:<5}")
    
    # Iterate through the rest of the bits
    step_count = 2
    for bit in binary_exp[1:]:
        prev_result = result
        
        # Always Square first
        result = (result * result) % modulus
        op_name = "Square"
        calc_desc = f"{prev_result}^2"
        
        # If bit is 1, also Multiply
        if bit == "1":
            result = (result * base) % modulus
            op_name = "Square & Multiply"
            calc_desc = f"({prev_result}^2) * {base}"
        
        print(f"{step_count:<5} | {bit:<3} | {op_name:<17} | "
              f"{calc_desc + ' mod n':<25} | {result:<5}")
        step_count += 1
    
    print("-" * 70)
    print(f"Final Result: {result}")

m = 1234
e = 24377
n = 41567

square_and_multiply(m, e, n)
\end{lstlisting}

\begin{table}[H]
\centering
\small
\begin{tabular}{|c|c|c|l|r|}
\hline
\textbf{Step} & \textbf{Bit} & \textbf{Operation} & \textbf{Calculation} & \textbf{Result} \\
\hline
1 & 1 & Initial & -- & 1234 \\
2 & 0 & Square & $1234^2 \bmod n$ & 26344 \\
3 & 1 & Square \& Multiply & $(26344^2) \times 1234 \bmod n$ & 39933 \\
4 & 1 & Square \& Multiply & $(39933^2) \times 1234 \bmod n$ & 583 \\
5 & 1 & Square \& Multiply & $(583^2) \times 1234 \bmod n$ & 11996 \\
6 & 1 & Square \& Multiply & $(11996^2) \times 1234 \bmod n$ & 6384 \\
7 & 1 & Square \& Multiply & $(6384^2) \times 1234 \bmod n$ & 28435 \\
8 & 0 & Square & $28435^2 \bmod n$ & 29508 \\
9 & 0 & Square & $29508^2 \bmod n$ & 18115 \\
10 & 1 & Square \& Multiply & $(18115^2) \times 1234 \bmod n$ & 21154 \\
11 & 1 & Square \& Multiply & $(21154^2) \times 1234 \bmod n$ & 26747 \\
12 & 1 & Square \& Multiply & $(26747^2) \times 1234 \bmod n$ & 22757 \\
13 & 0 & Square & $22757^2 \bmod n$ & 39363 \\
14 & 0 & Square & $39363^2 \bmod n$ & 35844 \\
15 & 1 & Square \& Multiply & $(35844^2) \times 1234 \bmod n$ & 26476 \\
\hline
\end{tabular}
\caption{Square-and-multiply steps for computing $1234^{24377} \bmod 41567$}
\end{table}

\textbf{Final Result:} $C = 26476$

\section{Exercise 3: Block Cipher Modes and Error Propagation}

This exercise analyzes error propagation in different block cipher modes when a single bit error occurs in the first ciphertext block $C_1$ during transmission. We assume 128-bit blocks.

\subsection{CBC Mode (Cipher Block Chaining)}

In CBC mode, the decryption process is defined as:
\begin{equation}
    P_i = D_k(C_i) \oplus C_{i-1}
\end{equation}
where $C_0$ is the initialization vector (IV).

\subsubsection{Effect on Decrypted Block $P_1$}

\textbf{Formula:} $P_1' = D_k(C_1) \oplus \text{IV}$

\textbf{Analysis:} If $C_1$ has 1 wrong bit, then the entire output of $D_k(C_1)$ is corrupted because the block cipher decryption is a deterministic function that is highly sensitive to input changes.

\textbf{Result:} The entire block $P_1'$ is completely corrupted (random garbage).

\textbf{Bits corrupted in $P_1$:} 128 bits

\subsubsection{Effect on Decrypted Block $P_2$}

\textbf{Formula:} $P_2' = D_k(C_2) \oplus C_1$

\textbf{Analysis:} $C_2$ is received correctly, so the output of $D_k(C_2)$ is correct. However, this result is XORed with $C_1$ (which contains the 1-bit error) to produce $P_2'$.

\textbf{Result:} $P_2'$ contains exactly one bit error at the same position as the error in $C_1$.

\textbf{Bits corrupted in $P_2$:} 1 bit

\subsubsection{Total Corruption in CBC Mode}

\begin{equation}
    \text{Total bits corrupted} = 128 + 1 = 129 \text{ bits}
\end{equation}

The first 128 bits are in $P_1$, and 1 bit is in $P_2$ at the same position where the error in $C_1$ occurred.

\subsection{CFB Mode (Cipher Feedback)}

In CFB mode, the decryption process is:
\begin{equation}
    P_i = C_i \oplus E_k(C_{i-1})
\end{equation}
where $C_0$ is the initialization vector (IV).

\subsubsection{Effect on Decrypted Block $P_1$}

\textbf{Formula:} $P_1' = C_1 \oplus E_k(\text{IV})$

\textbf{Analysis:} The keystream component $E_k(\text{IV})$ is generated using the IV, which is correct. The corruption is only in $C_1$, which is directly XORed with the keystream.

\textbf{Result:} $P_1$ contains exactly one bit error at the specific position where $C_1$ was corrupted.

\textbf{Bits corrupted in $P_1$:} 1 bit

\subsubsection{Effect on Decrypted Block $P_2$}

\textbf{Formula:} $P_2' = C_2 \oplus E_k(C_1)$

\textbf{Analysis:} To decrypt $P_2$, the algorithm must encrypt the previous ciphertext block $C_1$ to create the keystream. Since $C_1$ has a bit error and is the input to the encryption function $E_k$, the entire output is corrupted.

\textbf{Result:} The entire block $P_2'$ is completely corrupted (random garbage).

\textbf{Bits corrupted in $P_2$:} 128 bits

\subsubsection{Total Corruption in CFB Mode}

\begin{equation}
    \text{Total bits corrupted} = 1 + 128 = 129 \text{ bits}
\end{equation}

One bit is corrupted in $P_1$ at the same position where the error in $C_1$ occurred, and the remaining 128 bits are corrupted in $P_2$.

\section{Exercise 4: ElGamal Decryption}

Given: $p = 23$, $g = 5$, $C_1 = 20$, $C_2 = 22$, private key $x = 6$

\subsection{Calculate $C_1^x \bmod p$}

\begin{align*}
    C_1^x \bmod p &= 20^6 \bmod 23 \\
    &= 64000000 \bmod 23 \\
    &= 16 \bmod 23
\end{align*}

\textbf{Result:} $C_1^x \equiv 16 \pmod{23}$

\subsection{Find the Modular Multiplicative Inverse}

We need to find the modular multiplicative inverse of 16 modulo 23, i.e., we are looking for $(16)^{-1} \bmod 23$.

Let $k$ be the inverse. We need to satisfy:
\begin{equation}
    16 \cdot k \equiv 1 \pmod{23}
\end{equation}

\subsubsection{Using the Extended Euclidean Algorithm}

\textbf{Forward steps:}
\begin{align*}
    23 &= 1 \cdot 16 + 7 \\
    16 &= 2 \cdot 7 + 2 \\
    7 &= 3 \cdot 2 + 1
\end{align*}

\textbf{Backward substitution:}
\begin{align*}
    1 &= 7 - 3(2) \\
    &= 7 - 3(16 - 2(7)) \\
    &= 7 - 3(16) + 6(7) \\
    &= 7(7) - 3(16) \\
    &= 7(23 - 16) - 3(16) \\
    &= 7(23) - 7(16) - 3(16) \\
    &= 7(23) - 10(16)
\end{align*}

Therefore:
\begin{align*}
    1 &\equiv -10(16) \pmod{23} \\
    (16)^{-1} &\equiv -10 \equiv 13 \pmod{23}
\end{align*}

\textbf{Verification:}
\begin{equation*}
    16 \times 13 = 208 = 9 \times 23 + 1 \equiv 1 \pmod{23} \quad
\end{equation*}

\subsection{Decrypt to Find the Plaintext $M$}

The ElGamal decryption formula is:
\begin{equation}
    M = C_2 \cdot (C_1^x)^{-1} \bmod p
\end{equation}

Using the values we calculated:
\begin{align*}
    M &= 22 \cdot 13 \bmod 23 \\
    M &= 286 \bmod 23 \\
    M &= 10
\end{align*}

\textbf{Final Plaintext:} $M = 10$

\end{document}